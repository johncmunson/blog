---
title: How This Blog Works
---

# Owning My Blog (And Its Stack)

I didn’t want another hosted writing platform.

Medium, Substack, whatever-the-latest-thing-is... they’re fine, but they’re not mine. As a developer, I don’t just care about the words I publish; I care about the stack, the pipeline, and the amount of control I have over how those words are turned into HTML and shipped to a browser.

So I built this blog the way I wanted to:

- Static, fast, and boring-in-a-good-way.
- Markdown-only, with a custom pipeline I actually understand.
- Fully owned content, versioned in Git, deployed from GitHub to Vercel.
- Minimal design, clean typography, and just enough styling to not look like [1991](https://info.cern.ch/hypertext/WWW/TheProject.html).

This post is a technical tour of how it all works.

# The Shape of the App

At the routing level, this blog is intentionally tiny:

- A homepage that lists posts.
- A post page that renders any markdown file in the `content` directory.

That’s it.

In the Next.js app router, that boils down to two pages:

- `app/page.tsx` – the homepage.
- `app/[slug]/page.tsx` – the dynamic route for individual posts.

Each markdown file lives in the `content` directory and follows a very specific naming convention:

```text
YYYY-MM-DD.slug.md
```

For example:

```text
2025-12-03.kitchen-sink-markdown-test.md
```

The filename encodes two important things:

- The **date**, which I treat as the publish date.
- The **slug**, which becomes part of the URL.

The parsing logic for this lives in `lib/markdown.tsx`:

```ts
function parsePostFilename(filename: string): { date: string; slug: string } {
  const parts = filename.split(".");

  if (parts.length < 3) {
    throw new Error(
      `[markdown] Invalid content filename "${filename}". Expected format "YYYY-MM-DD.post-slug.md".`
    );
  }

  const [date, slug] = parts;

  return { date, slug };
}
```

I like this setup because the filesystem is the source of truth:

- The URL path comes from the filename.
- The publish date comes from the filename.
- RSS and the sitemap both read from the same directory.

# From Slugs to Markdown Files

The app router does the usual thing and precomputes static routes by enumerating the `content` directory.

In `app/[slug]/page.tsx`, I use `getAllPosts()` to generate all the valid `slug` parameters:

```ts
export async function generateStaticParams() {
  const posts = await getAllPosts();

  return posts.map((post) => ({
    slug: post.slug,
  }));
}
```

And then the page itself receives that slug and fetches the post data from the markdown pipeline:

```ts
export default async function PostPage({
  params,
}: {
  params: Promise<{ slug: string }>;
}) {
  const { slug } = await params;
  const post = await getPostData(slug);

  return <main>{/* title, date, and markdown content */}</main>;
}
```

The heavy lifting lives in `getPostData(slug)` in `lib/markdown.tsx`.

# A Custom Markdown Pipeline (On Purpose)

Next.js has solid MDX support. I intentionally didn’t use it.

I don’t like MDX as a spec. It mixes JSX and markdown in a way that, in my opinion, completely undermines what makes markdown elegant in the first place. Markdown should be a lightweight, predictable markup language and not a half-baked templating system.

On top of that, MDX as implemented in Next.js (and most other frameworks) feels a bit too magical for my taste. A lot of behavior is wired together behind the scenes: the bundler, the MDX loader, the JSX runtime, the component scope, etc. It isn’t always obvious what’s happening between your `.mdx` file and the React tree that ends up on the screen. I wanted an explicit, boring pipeline where every transformation step is visible and under my control.

So, I built a pipeline using the unified / remark / rehype ecosystem, wired up exactly the way I want.

At a high level, the pipeline looks like this:

1. Parse markdown to an AST.
2. Extract frontmatter into a structured object.
3. Enhance the AST with extra information (like image dimensions).
4. Convert markdown AST → HTML AST.
5. Run HTML transforms (syntax highlighting, heading slugs, autolinked headings, raw HTML support).
6. Finally, turn the HTML AST into React elements.

Here’s the core of that pipeline in `lib/markdown.tsx`:

```ts
function createMarkdownProcessor() {
  return unified()
    .use(remarkParse)
    .use(remarkFrontmatter)
    .use(() => (_: unknown, file: VFile) => {
      matter(file);
    })
    .use(remarkImageSize)
    .use(remarkGfm)
    .use(tightenBlockquoteLists)
    .use(remarkRehype, { allowDangerousHtml: true })
    .use(rehypeRaw)
    .use(rehypeShiki, {
      themes: {
        light: "one-light",
        dark: "one-dark-pro",
      },
    })
    .use(rehypeSlug)
    .use(rehypeAutolinkHeadings, {
      behavior: "append",
      content: [
        {
          type: "element",
          tagName: "span",
          properties: { "data-link-icon": "" },
          children: [],
        },
      ],
      properties: {
        class: "heading-anchor",
        ariaHidden: true,
        tabIndex: -1,
      },
      headingProperties: { class: "with-heading-anchor" },
    })
    .use(rehypeReact, {
      Fragment,
      jsx,
      jsxs,
      components: markdownComponents,
    });
}
```

Some highlights:

- `remark-parse` turns markdown into a proper AST.
- `remark-frontmatter` + `vfile-matter` extract YAML frontmatter into `file.data.matter`.
- `remark-gfm` gives me GitHub-flavored markdown: tables, task lists, etc.
- `remark-rehype` + `rehype-raw` let me safely embed raw HTML in markdown when I need it.
- `@shikijs/rehype` powers code block syntax highlighting.
- `rehype-slug` and `rehype-autolink-headings` add IDs and anchor links to headings.
- `rehype-react` takes the HTML AST and turns it into a React tree, using my custom components for links, images, etc.

I could have used the popular `gray-matter` package for frontmatter parsing, but I preferred to stay inside the unified / remark ecosystem as much as possible. `vfile-matter` plugs directly into the same pipeline and plays nicely with the rest of the tooling. It’s just another unified plugin.

Right now, the only required frontmatter field is `title`, but this setup makes it trivial to grow a richer metadata story over time: tags, series information, canonical URLs, or even RSS-specific fields. When I’m ready for features like “this is part 3 of a 5-part series” or more descriptive RSS entries, that information will live in frontmatter and flow through the exact same pipeline.

The end result is that each markdown file compiles to a React node tree, not a string of HTML I have to dangerously inject.

# Frontmatter and Post Metadata

Each markdown file starts with YAML frontmatter. I don’t go overboard with metadata. Right now I only require a `title`.

The relevant part of `getPostData` looks like this:

```ts
export async function getPostData(slug: string): Promise<PostData> {
  const filename = findFilenameBySlug(slug);

  if (!filename) {
    throw new Error(`Post not found for slug: ${slug}`);
  }

  const { date } = parsePostFilename(filename);
  const fullPath = path.join(contentDirectory, filename);

  const processor = createMarkdownProcessor();
  const file = await processor.process(await read(fullPath));

  const frontmatter = file.data.matter as Frontmatter | undefined;

  if (!frontmatter || !frontmatter.title) {
    throw new Error(
      `[markdown] Missing required "title" frontmatter in "${filename}".`
    );
  }

  const title = frontmatter.title;

  return {
    slug,
    date,
    title,
    content: file.result as React.ReactNode,
  };
}
```

A few design choices worth calling out:

- **Dates come from filenames**, not frontmatter. One source of truth.
- **Titles come from frontmatter**, so I can refactor filenames without changing the visible title.
- The `content` field is already a React node. By the time the page component renders, all markdown processing is done.

I could have put the date in frontmatter instead of the filename, but then my posts wouldn’t sort chronologically in my editor or in a plain `ls`. I also don’t want to duplicate the date in two places... if you care about correctness, you usually want a single source of truth. Encoding the date in the filename keeps things simple and keeps the filesystem itself meaningful.

Likewise, I technically could derive the title from the slug if I really wanted to, but that’s backwards. There are plenty of cases where you want a short, URL-friendly slug and a more expressive or quirky title, and those two shouldn’t be forced to match. Typically, if something is derived, it’s the slug that gets derived from the title, not the other way around.

I could have gone that route too by keeping `title` in frontmatter and auto-generating slugs, but then my filenames would lose semantic descriptiveness and only contain a date. That’s not very fun. I like being able to glance at the `content` directory and see both the date and the slug in the filename.

# Custom Markdown Behavior

Because this is a custom pipeline, I get to shape markdown behavior exactly how I like.

# Tight Lists in Blockquotes

There’s a long-standing quirk in remark where lists inside blockquotes render “loosely” (wrapped in extra `<p>` tags) compared to top-level lists.

I didn’t want that.

So I added a tiny plugin, `tightenBlockquoteLists`, that normalizes list items in blockquotes:

```ts
export const tightenBlockquoteLists: Plugin<[], Root> = () => {
  return (tree: Root) => {
    visit(tree, "blockquote", (blockquoteNode) => {
      const blockquote = blockquoteNode as Blockquote;

      visit(blockquote, "listItem", (listItemNode) => {
        const item = listItemNode as ListItem;
        if (
          item.children.length === 1 &&
          item.children[0].type === "paragraph"
        ) {
          const paragraph = item.children[0] as Paragraph;
          item.children = paragraph.children as typeof item.children;
        }
      });
    });
  };
};
```

Now, lists inside blockquotes look consistent with regular lists.

# Next.js-Aware Links and Images

I also override the default HTML elements to play nicely with Next.js.

For links, I want internal links to use `next/link`, but external links to open in a new tab with the proper `rel` attributes.

```ts
const CustomLink = (props: React.AnchorHTMLAttributes<HTMLAnchorElement>) => {
  const { href, children, ...rest } = props;

  if (href && (href.startsWith("/") || href.startsWith("#"))) {
    return (
      <Link href={href} {...rest}>
        {children}
      </Link>
    );
  }

  return (
    <a href={href} target="_blank" rel="noopener noreferrer" {...rest}>
      {children}
    </a>
  );
};
```

For images, I want to use `next/image`, but that means I need explicit `width` and `height`. Rather than make myself type them manually in every markdown file, I added a `remark-image-size` plugin.

```ts
const MarkdownImage = (props: ComponentProps<"img">) => {
  const { src, alt = "", width, height, ...rest } = props;

  if (typeof src !== "string" || src.length === 0) {
    throw new Error("[markdown] Missing image src while rendering markdown.");
  }

  const parsedWidth =
    typeof width === "number"
      ? width
      : Number.parseInt(String(width ?? ""), 10);
  const parsedHeight =
    typeof height === "number"
      ? height
      : Number.parseInt(String(height ?? ""), 10);

  if (!Number.isFinite(parsedWidth) || !Number.isFinite(parsedHeight)) {
    throw new Error(
      `[markdown] Missing image dimensions for "${src}". Did remark-image-size run?`
    );
  }

  return (
    <Image
      src={src}
      alt={alt}
      width={parsedWidth}
      height={parsedHeight}
      {...rest}
    />
  );
};
```

Behind the scenes, `remark-image-size` inspects each image node, resolves its path, and reads its dimensions using `image-size`:

```ts
export const remarkImageSize: Plugin<[RemarkImageSizeOptions?], Root> = (
  options = {}
) => {
  const { publicDir = path.join(process.cwd(), "public") } = options;

  return async (tree: Root, file: VFile): Promise<void> => {
    const tasks: Promise<void>[] = [];

    visit(tree, "image", (node) => {
      const imageNode = node as ImageNode;
      const url = decodeURI(imageNode.url);

      if (EXTERNAL_URL_REGEX.test(url)) {
        return;
      }

      let filePath: string;

      if (url.startsWith("/")) {
        filePath = path.join(publicDir, url);
      } else {
        if (!file.dirname) {
          throw new Error(
            `[remark-image-size] Found relative image path "${url}" but 'file.dirname' is not set on the VFile.`
          );
        }
        filePath = path.join(file.dirname, url);
      }

      const task = (async () => {
        const { imageSizeFromFile } = await import("image-size/fromFile");
        const size = await imageSizeFromFile(filePath);

        const width = size.width;
        const height = size.height;

        if (width == null || height == null) {
          throw new Error(
            `[remark-image-size] Could not determine width/height for "${url}" (resolved to "${filePath}")`
          );
        }

        if (!imageNode.data) imageNode.data = {};
        if (!imageNode.data.hProperties) imageNode.data.hProperties = {};

        imageNode.data.hProperties.width = String(width);
        imageNode.data.hProperties.height = String(height);
      })();

      tasks.push(task);
    });

    if (tasks.length > 0) {
      await Promise.all(tasks);
    }
  };
};
```

That means I can write simple markdown like:

```md
![Alt text](/images/example.png)
```

…and the build will fail loudly if the image file is missing or its size can’t be determined. That’s exactly the kind of failure mode I want.

# Styling: Minimal, But Not Ugly

Visually, I wanted something that feels almost like old-school HTML: mostly unstyled, content-first, and not covered in gradients and motion.

But I still care about typography. So I reached for Tailwind CSS and Tailwind Typography.

The setup is intentionally small:

- Tailwind v4 via the `@tailwindcss/postcss` plugin.
- Tailwind Typography for the `prose` class.
- A handful of custom CSS variables for dark mode and typography tweaks.

In `postcss.config.mjs`:

```js
export default {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};
```

In `app/globals.css`, I pull in Tailwind and the typography plugin:

```css
@import "tailwindcss";
@plugin "@tailwindcss/typography";
```

Then I define a very small design system using CSS variables and Tailwind’s new `@theme inline` feature:

```css
:root {
  --background: #f5f5f5;
  --foreground: #0a0a0a;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #050505;
    --foreground: #f5f5f5;
  }
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
}
``;
```

The layout applies this with a simple `prose` wrapper. In `app/layout.tsx`:

```tsx
<body
  className={cn(
    "min-h-screen bg-background text-foreground",
    "antialiased",
    "font-sans"
  )}
>
  <main className="mx-auto max-w-2xl px-4 py-10 prose">{children}</main>
</body>
```

Tailwind Typography gives me a nice baseline for headings, paragraphs, and lists. I tweak a few details for things like heading anchors and blockquotes, but mostly I let it do its job.

# Shiki-Powered Code Blocks

For code blocks, I use Shiki via `@shikijs/rehype`. The markdown pipeline passes fenced code blocks through Shiki, which emits HTML with `.shiki` classes.

In `lib/markdown.tsx`:

```ts
.use(rehypeShiki, {
  themes: {
    light: "one-light",
    dark: "one-dark-pro",
  },
})
```

In `globals.css`, I style the `.shiki` output and hook it into dark mode via the same `prefers-color-scheme` query. The result is consistent, readable code blocks that match the rest of the aesthetic without screaming “syntax highlighter”.

# Hot Reloading Markdown

When I’m writing, I want fast feedback. The default Next.js dev server will happily reload when you change React components, but it doesn’t know anything about your `.md` files.

So I wired up my own tiny watcher.

The idea is simple:

1. Watch the `content` directory for changes to `.md` files.
2. When a file changes, touch a special `tmp/reload-trigger.ts` file.
3. Import that file in `lib/markdown.tsx` so Next.js treats it as a dependency.
4. When the trigger file changes, Next.js invalidates the module graph, and the markdown pipeline re-runs.

Here’s the watcher in `scripts/watch-content.ts`:

```ts
const CONTENT_DIR = path.join(process.cwd(), "content");
const TRIGGER_FILE = path.join(process.cwd(), "tmp", "reload-trigger.ts");

fs.mkdirSync(path.dirname(TRIGGER_FILE), { recursive: true });
fs.closeSync(fs.openSync(TRIGGER_FILE, "a"));

function triggerReload() {
  const stamp = `// reload: ${Date.now()}`;
  fs.writeFileSync(TRIGGER_FILE, stamp);
  console.log("[HMR] Triggered reload:", stamp);
}

function watchMarkdownFiles() {
  console.log(`Watching markdown files in: ${CONTENT_DIR}`);

  fs.watch(CONTENT_DIR, { recursive: true }, (eventType, filename) => {
    if (!filename) return;

    if (filename.endsWith(".md")) {
      console.log(`[watcher] Change detected in: ${filename}`);
      triggerReload();
    }
  });
}

watchMarkdownFiles();
```

And then, in `lib/markdown.tsx`, I import the trigger file purely for its side effect on the module graph:

```ts
import "@/tmp/reload-trigger";
```

Finally, I wire it up in `package.json`:

```json
"scripts": {
  "dev": "next dev",
  "dev:watch": "concurrently \"tsx scripts/watch-content.ts\" \"pnpm dev\""
}
```

So my local workflow looks like this:

```bash
pnpm dev:watch
```

When I edit a markdown file, the watcher sees the change, rewrites `tmp/reload-trigger.ts`, and Next.js reloads the markdown module. It’s not HMR in the strictest sense, but in practice it feels like it.

# RSS, Sitemap, and SEO

Because all content lives in the `content` directory, generating RSS and a sitemap is straightforward.

# RSS

The RSS route lives at `app/rss.xml/route.ts`.

At a high level, it:

1. Reads all `.md` files from `content`.
2. Parses filenames into dates and slugs.
3. Uses a tiny markdown pipeline to read frontmatter titles.
4. Emits an RSS 2.0 XML string.

Here’s the core of the route handler:

```ts
export async function GET() {
  const posts = await getAllRssPosts();
  const feed = buildRssFeed(posts);

  return new Response(feed, {
    status: 200,
    headers: {
      "Content-Type": "application/xml; charset=utf-8",
    },
  });
}
```

And `buildRssFeed` does the string assembly, using the same date/slug information that the rest of the app uses.

# Sitemap

The sitemap lives at `app/sitemap.ts`.

Next.js expects this file to export a function that returns a list of URLs. I reuse the same `getAllPosts()` function that powers the homepage.

```ts
export default async function sitemap() {
  const posts = await getAllPosts();

  return [
    {
      url: `${baseUrl}/`,
      lastModified: new Date(),
    },
    ...posts.map((post) => ({
      url: `${baseUrl}/${post.slug}`,
      lastModified: new Date(post.date),
    })),
  ];
}
```

Again, the filesystem is the source of truth. Add a markdown file, and you automatically get:

- A new post page.
- A new entry on the homepage.
- A new entry in the RSS feed.
- A new entry in the sitemap.

# Tooling: pnpm, TypeScript, and Vercel

Under the hood, this is a TypeScript, pnpm, Next.js 16, React 19 setup. Nothing exotic, but each choice is deliberate.

# pnpm

I use pnpm for the classic reasons:

- It’s faster.
- It’s more space-efficient.
- It has a better story for workspaces and monorepos.

Even though this is a small blog today, I like knowing I can grow the repo into a monorepo later without regretting my package manager choice.

# TypeScript Everywhere

The project is written in TypeScript from top to bottom. The markdown pipeline, plugins, and components all have types. That matters here, because a lot of the markdown integration points involve loosely-typed ASTs and VFile metadata.

TypeScript gives me a safety net as I tweak the pipeline and add new plugins.

# GitHub + Vercel

Deploying this blog is intentionally boring:

- The repo lives on GitHub.
- Vercel is connected to the main branch.
- When I push a commit, Vercel builds and deploys.

Publishing a new post is literally:

```bash
git commit -am "Add blog architecture post"
git push
```

That’s it.

# Why This Stack Fits This Blog

This stack is probably overkill for a three-page site. But I picked it for how it feels to work with, not for the number of routes.

- **Next.js + Vercel** are a perfect fit for a mostly-static blog that might grow dynamic features later.
- **Markdown + unified/remark/rehype** give me a fully controllable pipeline without swallowing MDX.
- **Tailwind + Tailwind Typography** give me clean, minimal styling with very little CSS.
- **pnpm** keeps the tooling sharp and ready for future growth.
- **Git + GitHub + Vercel** make deployment a non-event.

Most importantly: I own the whole thing.

The content is just markdown files in a repo I control. The pipeline is code I wrote (and understand). The deployment is a push away. If any single piece of this stack stops making sense, I can replace it.

For a developer blog, that’s exactly how I want it.
