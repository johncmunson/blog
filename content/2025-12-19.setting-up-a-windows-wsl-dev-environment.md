---
title: Setting Up a Windows + WSL Dev Environment
description: An opinionated but practical guide to creating a modern, Linux-based development environment on a Microsoft-powered machine. Optimized for everyday work.
---

Windows is definitely not the best platform for most forms of development work. But also... it kind of is! The fact that you can run a Linux kernel inside of Windows is a really powerful feature, and it's a shame that it's not more widely adopted.

With WSL, you can have the best of both worlds: the stability and performance of Linux for all your development work, and the convenience and familiarity of Windows for everything else.

This post walks you through the steps to get up and running quickly. Some items are optional and may not apply to you, but things like WSL, Git, and Docker are absolutely required for a smooth developer experience. Below is a summary of what is covered:

- [WSL](https://learn.microsoft.com/en-us/windows/wsl/)
- [Git](https://git-scm.com/)
- [Docker](https://www.docker.com/)
- [Fish Shell](https://fishshell.com/)
- [Starship Prompt](https://starship.rs/)
- [Node](https://nodejs.org/) / [fnm](https://github.com/Schniz/fnm) / [pnpm](https://pnpm.io/)
- [Bun](https://bun.sh/)
- [Remapping Caps Lock to Esc](https://learn.microsoft.com/en-us/windows/powertoys/keyboard-manager)
- [VS Code](https://code.visualstudio.com/)
- [Cursor](https://www.cursor.com/)

# Get up and running with WSL

The first step is to [install WSL](https://learn.microsoft.com/en-us/windows/wsl/install), i.e. the Windows Subsystem for Linux. This is a Linux kernel running inside of Windows, and it allows you to run Linux commands and applications directly on Windows. It's important to understand that when you enable WSL, you are installing a new filesystem, completely separate from the Windows filesystem. For this reason, all of your development files and projects should be stored in the WSL filesystem, not the Windows filesystem, if you want optimal performance and stability.

For the vast majority of developers, you probably just want to install the default Ubuntu distribution. This is what you will get when running the following command in PowerShell:

```bash
wsl --install
```

To list all available distros and install something other than the default:

```bash
wsl --list --online
wsl --install <distro-name>
```

While WSL allows you to install multiple Linux distros, it _does not_ allow you to install multiple instances of the same distro. For example, if you installed the disto named `AlmaLinux-10`, you cannot install another `AlmaLinux-10`. The closest you could get would be to install `AlmaLinux-9`.

> **Note**: The only exception to this rule is if you install the default `Ubuntu` distro, which always uses the most recent LTS version of Ubuntu. Because WSL also typically provides an explicitly named Ubuntu LTS distro, you can technically install both `Ubuntu` and `Ubuntu-24.04` and have two instances of the same Ubuntu version installed.

Once you have a distro installed, pop open Windows Terminal and navigate to the settings page. Here, you can change the default profile to the distro you just installed. Now, you will be dropped into a Linux shell, as opposed to Windows Powershell, whenever you open a new terminal window or tab. This is slightly different from actually setting the default WSL distro, which is done by running `wsl --set-default <distro-name>`. Just remember to keep these two things in sync if you commonly use multiple distros and want to avoid accidentally using the wrong one.

As a final note, assuming you installed an Ubuntu or Debian-based distro, it's a good habit to occasionally run `sudo apt update && sudo apt upgrade` to ensure your packages are up to date. For other distros, the command may be different.

# Git Configuration

You should install `git` in **both** Windows and your WSL distro. Git running inside WSL is what you’ll actually use day-to-day for development, but installing Git for Windows gives you access to **Git Credential Manager (GCM)**, which acts as the bridge between the two environments. This setup lets WSL Git securely reuse your Windows-stored credentials instead of prompting you to authenticate repeatedly.

- **WSL Git** operates on the Linux filesystem where your code lives.
- **Git for Windows** includes Git Credential Manager, which stores credentials in Windows Credential Manager and supports modern auth flows (browser login, MFA, tokens).
- With GCM, both Windows and WSL Git share the same credentials cleanly.

Setup overview:

1. **Install Git for Windows**  
   Download and install from https://git-scm.com/install/windows.  
   During setup, keep the default option to use **Git Credential Manager**.

2. **Install Git in WSL** (if not already present):

   ```bash
   sudo apt update
   sudo apt install git
   ```

3. **Verify GCM is visible from WSL**:
   ```bash
   git --version
   git credential-manager --version
   ```
   If this works, WSL Git will automatically delegate authentication to GCM.

From this point on, the first time you access a GitHub repo over HTTPS, a Windows browser window will open to authenticate. After that, credentials are reused transparently.

Next, at a minimum, you will want to configure `git` with your username and email once in WSL:

```bash
git config --global user.name "Your Name"
git config --global user.email "123456+username@users.noreply.github.com"
```

GitHub provides a **private noreply email address** specifically for commits. Using it prevents your real email from appearing in public repositories while still associating commits with your account. You can find or enable this address in your GitHub email settings.

That's all that's required for a clean, low-friction `git` setup on Windows + WSL.

# Setting up Docker

Even if your primary deployment target isn’t a Docker image, Docker is still a really valuable tool to have in your day-to-day dev toolkit.

Docker shines as a **convenience layer** for development. It lets you spin up things like databases, caches, message queues, or other infrastructure dependencies without installing, configuring, and maintaining them directly on your system. Need Postgres, Redis, or Elasticsearch for a project? A simple `docker run` or `docker compose up -d` command beats hunting down installers and tuning config files every time.

It’s also great for **one-off or unfamiliar tech**. Maybe you don’t normally work in Python, but you want to test a library, run a script, or prototype something quickly. Docker lets you do that in an isolated environment without polluting or breaking your main setup. When you’re done, you can throw it away just as easily.

Think of Docker as a clean, disposable sandbox that complements your normal development environment, rather than replacing it.

> **Note**: If you’re primarily a Node developer (or Go, Rust, Java, etc.), I still recommend installing your core language toolchain directly in WSL. That’s where your editor, shell, package manager, and build tools will feel the most natural and responsive. Docker is excellent for dependencies and edge cases, but for the language you work in every day, having it installed natively in your WSL distro keeps things simple and fast. Use Docker when it adds leverage, not friction.

The easiest and most reliable way to use Docker with WSL is via **Docker Desktop for Windows**.

High-level steps:

1. Install Docker Desktop for Windows.
2. During setup (or afterward in settings), enable the **WSL 2 based engine**.
3. In Docker Desktop settings, enable **WSL integration** for the distro you actually use (e.g. Ubuntu).
4. Restart Docker Desktop if prompted.

Once this is done, the Docker CLI will be available inside your WSL environment, and commands like `docker ps` or `docker run` will just work from your Linux shell. You don’t need to install Docker Engine separately inside WSL, since Docker Desktop handles that plumbing for you.

The important mental model: Docker Desktop runs the engine, WSL provides the shell and filesystem context, and they’re wired together behind the scenes.

A quick note on **VS Code Dev Containers**...

VS Code dev containers let you define an entire development environment (language runtime, tools, extensions, etc.) inside a Docker container and then attach your editor to it. This can be great for fully reproducible setups, team consistency, or complex stacks.

They're powerful, but also a step up in complexity. For most local development, especially when you're just using Docker for dependencies or experimentation, they aren't really needed. I appreciate using them when developing on macOS, because it truly allows me to keep my development environment completely isolated from my personal system. But on Windows, I'm kind of already benefiting from the isolation provided by WSL, so I don't need the extra complexity of dev containers.

# Use the `fish` shell!

You absolutely **do not** need to install or use `fish` to have a great WSL setup. `bash` is perfectly fine and already familiar to most developers. If you're comfortable in `bash` and don't feel any friction, there's no requirement to change anything, just stick with what works.

That said, `fish` (the _Friendly Interactive SHell_) is worth considering. It's a modern shell with excellent defaults: smart autosuggestions based on your history, syntax highlighting as you type, and a generally polished, pleasant interactive experience without needing much configuration. Julia Evans has a [great post](https://jvns.ca/blog/2024/09/12/reasons-i--still--love-fish/) on exactly this topic.

On Ubuntu or other Debian-based distros, installation is straightforward:

```bash
sudo apt update && sudo apt install -y fish
```

Before you can set `fish` as your default shell, it must be listed in `/etc/shells`. Check the file:

```bash
cat /etc/shells
```

If `/usr/bin/fish` is not present, add it (as root):

```bash
echo /usr/bin/fish | sudo tee -a /etc/shells
```

Once it's registered, you can make `fish` your default login shell:

```bash
chsh -s /usr/bin/fish
```

Log out and back in (or restart your terminal), and you'll be dropped into `fish` automatically. If you ever want to switch back to `bash`, you can run `chsh -s /bin/bash` the same way.

That's it! It's optional, but highly recommended if you enjoy a more ergonomic shell experience.

# Upgrading your shell prompt with `starship`

`fish` already improves your shell experience quite a bit, but your **prompt** is still an area where you can add a lot of value with very little effort. This is where `starship` comes in.

`starship` is a fast, cross-shell prompt that gives you useful context at a glance: current directory, git status, language runtimes, exit codes, and more. Even if you're using `fish`, which already has great autosuggestions and syntax highlighting, `starship` complements it nicely by making the prompt itself more informative and consistent across machines.

Another nice property is that `starship` is purely cosmetic. It doesn't change shell behavior, aliases, or keybindings whatsoever.

Installation is a single command:

```bash
curl -sS https://starship.rs/install.sh | sh
```

To hook starship into `fish`, add the following line to the end of `~/.config/fish/config.fish`:

```bash
starship init fish | source
```

Restart your terminal and `starship` will take over rendering the prompt.

By default, `starship` uses nerd fonts, which are patched fonts that include extra glyphs for icons (git symbols, language logos, arrows, etc.). Some people love them; others find them noisy or unnecessary.

I'm firmly in the second camp, which is why I configure `starship` to use the "No Nerd Fonts" preset:

```bash
starship preset no-nerd-font -o ~/.config/starship.toml
```

This gives you a clean, readable prompt with zero special glyphs. As a bonus, this preset is slated to become the default in a future `starship` release, so you're already aligned with where things are heading.

# Install Node with `fnm`

`fnm` is a fast, modern Node.js version manager that is a great alternative to `nvm`, which is popular but bloated. It's a single binary that is easy to install and use, and it comes with a small set of powerful features. I can also highly recommend `n`, which is similar in spirit to `fnm`, but it's an aging project and I feel that nowadays `fnm` is the best choice.

To install, first ensure that both `curl` and `unzip` are available. If not, install them:

```bash
sudo apt update && sudo apt install -y curl unzip
```

Then, install `fnm`:

```bash
curl -fsSL https://fnm.vercel.app/install | bash
```

Once installed, be sure to configure `fnm` shell completions. This will allow you to use tab completion for `fnm` commands.

```bash
fnm completions --shell fish > ~/.config/fish/completions/fnm.fish
```

The last step is to decide which `fnm` behavior you want to opt into. For me, I opt into all of it, so my `~/.config/fish/conf.d/fnm.fish` file looks like this:

```bash
set FNM_PATH "$HOME/.local/share/fnm"
if test -d "$FNM_PATH"
    set -gx PATH "$FNM_PATH" $PATH
    fnm env --use-on-cd --version-file-strategy=recursive --corepack-enabled --resolve-engines --shell fish | source
end
```

Now that `fnm` is installed and configured, it's time to install the Node version you want to use. Might as well start with the latest LTS version.

```bash
fnm install --lts
```

Additionally, because I configured `fnm` with `--use-on-cd`, `--corepack-enabled`, and `--resolve-engines`, I can simply `cd` into any Node project and have the correct version of Node and `pnpm` installed and automatically activated. This is assuming that you have a `package.json` file and pin your versions appropriately.

```json
{
  "engines": {
    "node": ">=24"
  },
  "packageManager": "pnpm@10.26.0"
}
```

> **Note**: `fnm` does not directly manage `pnpm` like it does Node, it simply enables `corepack`, which allows you to use `pnpm` as your package manager. If you want to upgrade `pnpm` or change package managers, just change the `packageManager` field in your `package.json` file and `corepack` will pick it up automatically. The same thing applies to what version of Node you want to use, the difference is just that `fnm` is the thing managing Node, and `corepack` is the thing managing `pnpm`.

# Install Bun

Even if you're not planning to use Bun as your primary runtime or package manager, it's worth having installed. Bun is extremely fast at running scripts, and many projects now include `bun` commands alongside `npm` or `pnpm`. It's also a great tool for quickly running TypeScript files without any build step, which makes it handy for one-off scripts or experimentation.

```bash
curl -fsSL https://bun.sh/install | bash
```

That's it. Bun is a self-contained binary, so there's no extra configuration required. Version managers like [BunVM](https://bunvm.com/) exist, but since I still primarily use Node, I don't bother with one. When I want to update Bun, I just run `bun upgrade`.

# Remapping Caps Lock to Esc

This is a personal preference, but I find it to be a really useful way to improve my productivity. If you're a `vim` user, I _highly_ recommend it.

To remap Caps Lock to Esc, follow these steps:

1. Install Microsoft PowerToys. Install on Windows, not within WSL.
2. Launch PowerToys and enable Keyboard Manager. Optionally, disable other modules that you don't need.
3. Use Keyboard Manager to swap the Caps Lock and Esc keys.
4. Enjoy your reduced pinky strain :)

# Install VS Code

VS Code is a great default IDE, especially when working in a WSL environment. The reason for this, and why other IDEs are _not_ the best fit for WSL, is because your IDE is a GUI application that ideally should be installed and running in the Windows environment, not the WSL environment, because GUI applications are the most stable and performant this way. However, your IDE still needs to be able to access your WSL filesystem and run commands within it. VS Code really shines here because it translates between the two environments seamlessly, while other editors like Cursor are a buggy mess.

Follow these steps for a smooth VS Code installation that works with WSL:

1. Download the Windows installer from their website and run it.
2. During setup, be sure to enable the "Add to PATH" option.
3. Once installed, open a WSL terminal and run `code` to launch VS Code.
4. Install the WSL extension for VS Code.

Now that VS Code and the WSL extension are installed, you can launch any folder or project from the WSL terminal by `cd`'ing into it and running `code .`. When it opens, you should see in the bottom left corner something like `>< WSL: Ubuntu`. This means that VS Code is successfully connected to your WSL environment and you can now edit files, run commands, and more. All within the context of WSL.

# Super Duper Optional Step: Install Cursor

Copilot, the coding agent that comes native with VS Code, is pretty solid and gets the job done. Some people seem to think that it's subpar compared to other tools like Claude Code or Codex CLI, but I've been pretty happy with it. However, sometimes I will reach for Cursor instead.

Unlike other coding agents, which typically run in the CLI or as a VS Code extension, Cursor is a full-blown VS Code _fork_, which allows it to go further with providing a polished AI-assisted development experience.

Really though, Cursor just has _one killer feature_ right now that I haven't found in any other tool, and it's called **Parallel Agents**.

Essentially, the Parallel Agents feature allows you to type a single prompt and dispatch it to multiple agents/LLMs at once, each working within their own isolated git worktree. This is a really powerful feature, as it allows you to quickly compare and review mulltiple different approaches to solving a problem.

There is one **big huge caveat** though...

Cursor, when installed the traditional way similar to VS Code, is a complete buggy mess when working in a WSL environment. There are just [so many bugs](https://forum.cursor.com/search?q=wsl%20%23support%3Abug-report), many of them due to the fact that Cursor completely mangles file paths when trying to access the WSL filesystem or run commands within it.

To get around this, you actually need to install Cursor as a Linux GUI app within WSL itself. This is a bit of a pain, and it comes with its own set of drawbacks, but it's the best option right now if you want to use Cursor with WSL.

Here are the steps that I followed to get everything working:

1. From a WSL terminal, run `sudo apt install wslu`. This enables Cursor to open a new tab in your browser and is mainly important for getting past the login prompt.
2. Download the `Linux .deb (x64)` installer from their website.
3. Move the installer to the home directory of your WSL distro.
4. Run the installer: `sudo apt install ./cursor_2.2.36_amd64.deb`.
5. When prompted, select "Yes" for adding the Cursor apt repository. This will allow you to easily update Cursor later.
6. Delete the installer.
7. When running `cursor .` from the terminal, Cursor will complain about not being installed on the Windows host. But remember, Cursor is not allowed to complain here. It's their fault for not working with WSL when installed that way. To silence this warning, set the `DONT_PROMPT_WSL_INSTALL` env variable for your shell. For fish shell, run `set -Ux DONT_PROMPT_WSL_INSTALL 1`.
8. Edit `~/.cursor/argv.json` and set `"disable-hardware-acceleration": true`. You can also do this from the command palette by searching "Configure Runtime Arguments". This prevents Cursor from thrashing about trying to use GPU acceleration, which is not supported when running as a Linux GUI app within WSL.
9. That's it! You should now be able to `cd` into a project and run `cursor .` to open it in Cursor. You'll be prompted to login, which will open a new tab in your browser. This _should_ work as long as you installed `wslu` in step 1.

> **Note:** Remember those Linux GUI drawbacks I mentioned earlier? Well, here’s what you need to be aware of. When Cursor runs as a Linux GUI app, it is rendered through WSLg, which is a compatibility layer that translates Linux windowing (Wayland/X11) into Windows windows. This extra translation layer can make the UI feel a little buggy, wonky, or unstable, especially around window management and input handling.
>
> In practice, this means that actions like double-clicking the title bar to maximize, using fullscreen mode, or rapidly resizing the window can leave Cursor in a weird or stuck state where the window size is slightly wrong and mouse clicks no longer line up with the cursor. Nothing is actually "broken" inside Cursor. It's just that Windows, WSLg, and Electron simply disagree about window geometry and DPI scaling. To avoid these issues, treat Cursor like a manually sized window and you should be fine.

# Final Thoughts

Developing on a Windows machine with WSL is honestly a pretty great experience, which I was not initially expecting. I've been using it for several months now and have had very few complaints or issues. I'm now no longer of the belief that Windows is a second-class citizen when it comes to development or that you're at a disadvantage if you're using it.
